model LevelCrossingCase0 {

	// TODO
	class SUS {
		// actionneurs
		public composite lumiere[1-1] : Lumiere;
		public composite son[1-1] : Son;
		public composite barriere[1-1] : Barriere;

		// capteurs
		public composite dispatcher[1-1] : Dispatcher;

		// objets actifs
		public composite controleur[1-1] : Controleur;	// ou CSR
		public composite gestionnaireAnnonce[1-1] : GestionnaireAnnonce;
		public composite gestionnaireLiberation[1-1] : GestionnaireLiberation;	// TODO: ne pas reparser pour completion à chaque caractère tapé sans autre déplacement curseur (sinon trop lent)

		// objets actifs gérant des conditions
		public composite conditionOuverture[1-1] : ConditionOuverture;
		public composite conditionFinAnnonce[1-1] : ConditionFinAnnonce;

		connector "controleur-lumiere" : Controleur_Lumiere between controleur and lumiere;
		connector "controleur-son" : Controleur_Son between controleur and son;
		connector "controleur-barriere" : Controleur_Barriere between controleur and barriere;

		connector "controleur-gestionnaireAnnonce" : GestionnaireAnnonce_Controleur between gestionnaireAnnonce and controleur;
		connector "conditionOuverture-gestionnaireAnnonce" : GestionnaireAnnonce_ConditionOuverture between gestionnaireAnnonce and conditionOuverture;
		connector "gestionnaireLiberation-gestionnaireAnnonce" : GestionnaireAnnonce_GestionnaireLiberation between gestionnaireAnnonce and gestionnaireLiberation;
		connector "controleur-gestionnaireLiberation" : GestionnaireLiberation_Controleur between gestionnaireLiberation and controleur;
		connector "gestionnaireAnnonce-conditionFinAnnonce" : ConditionFinAnnonce_GestionnaireAnnonce between conditionFinAnnonce and gestionnaireAnnonce;
		connector "gestionnaireLiberation-conditionOuverture" : ConditionOuverture_GestionnaireLiberation between conditionOuverture and gestionnaireLiberation;

		// connections aux capteurs
		connector "gestionnaireAnnonce-dispatcher" : Dispatcher_GestionnaireAnnonce between dispatcher and gestionnaireAnnonce;
		connector "dispatcher-conditionFinAnnonce" : Dispatcher_ConditionFinAnnonce between dispatcher and conditionFinAnnonce;
		connector "dispatcher-conditionOuverture" : Dispatcher_ConditionOuverture between dispatcher and conditionOuverture;
		connector "dispatcher-controleur" : Dispatcher_Controleur between dispatcher and controleur;
		connector "dispatcher-gestionnaireLiberation" : Dispatcher_GestionnaireLiberation between dispatcher and gestionnaireLiberation;
	}


	association Controleur_Lumiere {
		controleur[1-1] : Controleur;// in Controleur_Lumiere;
	}
	association Controleur_Son {
		controleur[1-1] : Controleur;// in Controleur_Son;
	}
	association Controleur_Barriere {
		controleur[1-1] : Controleur;// in Controleur_Barriere;
	}

	association GestionnaireAnnonce_Controleur {
		gestionnaireAnnonce[1-1] : GestionnaireAnnonce;
	}
	association GestionnaireAnnonce_ConditionOuverture {
		gestionnaireAnnonce[1-1] : GestionnaireAnnonce;
	}
	association GestionnaireAnnonce_GestionnaireLiberation {
		gestionnaireAnnonce[1-1] : GestionnaireAnnonce;
	}

	association GestionnaireLiberation_Controleur {
		gestionnaireLiberation[1-1] : GestionnaireLiberation;
	}

	association ConditionFinAnnonce_GestionnaireAnnonce {
		conditionFinAnnonce[1-1] : ConditionFinAnnonce;
	}

	association ConditionOuverture_GestionnaireLiberation {
		conditionOuverture[1-1] : ConditionOuverture;
	}

	signal sysInit;
	signalEvent sysInitSE of sysInit;
	interface IInitialisable receives sysInit(sysInit) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |Controleur| behavesAs SM implements IConsommateurLiberation, IConsommateurAnnonce, IInitialisable {
		lumiere[1-1] : Lumiere in Controleur_Lumiere;
		son[1-1] : Son in Controleur_Son;
		barriere[1-1] : Barriere in Controleur_Barriere;
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				Initialisation -> Repos : sysInitSE /;
				Repos -> Approche : annonceApprocheSE / 
						opaqueBehavior = '
											send clignote to lumiere;
											send debute to son;
											send ferme to barriere;
										' in ABCD;;
				Approche -> Passage : annoncePassageSE /
						opaqueBehavior = '
											send allume to lumiere;
											send arret to son;
										' in ABCD;;
				Passage -> Repos : liberationSE /
						opaqueBehavior = '
											send eteint to lumiere;
											send ouvre to barriere;
										' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}

	signal annonceApproche;
	signalEvent annonceApprocheSE of annonceApproche;
	signal annoncePassage;
	signalEvent annoncePassageSE of annoncePassage;
	signal annonceInactive;
	signalEvent annonceInactiveSE of annonceInactive;
	interface IConsommateurAnnonce receives annonceApproche(annonceApproche), annoncePassage(annoncePassage), annonceInactive(annonceInactive) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |GestionnaireAnnonce| behavesAs SM implements IConsommateurFinAnnonce, IConsommateurZ3, IConsommateurZ5, IConsommateurPedale, IInitialisable {
		public controleur[1-1] : Controleur in GestionnaireAnnonce_Controleur;
		public conditionOuverture[1-1] : ConditionOuverture in GestionnaireAnnonce_ConditionOuverture;
		public gestionnaireLiberation[1-1] : GestionnaireLiberation in GestionnaireAnnonce_GestionnaireLiberation;
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				Initialisation -> Inactive : sysInitSE /;
				Inactive -> Approche : pedaleEnclencheeSE /
						opaqueBehavior = '
							send annonceApproche to controleur;
							send annonceApproche to conditionOuverture;
							send annonceApproche to gestionnaireLiberation;
						' in ABCD;;
				Approche ->  Passage : Z5OccupeSE /
						opaqueBehavior = '
							send annoncePassage to controleur;
						' in ABCD;;
				Passage -> Approche : Z3OccupeSE /;
				Passage -> Inactive : finAnnonceSE /
						opaqueBehavior = '
							send annonceInactive to conditionOuverture;
							send annonceInactive to gestionnaireLiberation;
						' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}

	signal liberation;
	signalEvent liberationSE of liberation;
	interface IConsommateurLiberation receives liberation(liberation) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |GestionnaireLiberation| behavesAs SM implements IConsommateurAnnonce, IConsommateurOuverture, IInitialisable {
		public controleur[1-1] : Controleur in GestionnaireLiberation_Controleur;
												// TODO: check missing initialization in composite structure
		stateMachine SM {						// TODO: check waiting for event that no one sends to us?
			region R {
				Initial -> Initialisation;
				Initialisation -> Ouvert : sysInitSE /;
				Ouvert -> Ferme : annonceApprocheSE /;
				Ferme -> Ouvert : ouvertureSE /
						opaqueBehavior = '
							send liberation to controleur;
						' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}


	primitiveType bool;

	signal finAnnonce;
	signalEvent finAnnonceSE of finAnnonce;
	interface IConsommateurFinAnnonce receives finAnnonce(finAnnonce) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |ConditionFinAnnonce| behavesAs SM implements IConsommateurZ1, IConsommateurZ3, IConsommateurZ5, IInitialisable {	// Autres noms : Af, Z1ouZ3ouZ5
		private z1[1-1] : bool;
		private z3[1-1] : bool;
		private z5[1-1] : bool;

		public gestionnaireAnnonce[1-1] : GestionnaireAnnonce in ConditionFinAnnonce_GestionnaireAnnonce;
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				Initialisation -> Ecoute : sysInitSE /
						opaqueBehavior = '
							z1 := false;
							z3 := false;
							z5 := false;
						' in ABCD;;
				Ecoute -> Ecoute : Z1OccupeSE /
						opaqueBehavior = '
							z1 := true;
						' in ABCD;;
				Ecoute -> Ecoute : Z3OccupeSE /
						opaqueBehavior = '
							z3 := true;
						' in ABCD;;
				Ecoute -> Ecoute : Z5OccupeSE /
						opaqueBehavior = '
							z5 := true;
						' in ABCD;;
				Ecoute -> Condition : Z1LibreSE /
						opaqueBehavior = '
							z1 := false;
						' in ABCD;;
				Ecoute -> Condition : Z3LibreSE /
						opaqueBehavior = '
							z3 := false;
						' in ABCD;;
				Ecoute -> Condition : Z5LibreSE /
						opaqueBehavior = '
							z5 := false;
						' in ABCD;;
				Condition -> Ecoute : [constraint is opaqueExpression = 'not (z1 or z3 or z5)' in ABCD;] /
						opaqueBehavior = '
							send finAnnonce to gestionnaireAnnonce;
						' in ABCD;;
				Condition -> Ecoute : [constraint is opaqueExpression = 'else' in ABCD;] /;
				initial pseudoState Initial;
				choice pseudoState Condition;
			}
		}
	}

	signal ouverture;
	signalEvent ouvertureSE of ouverture;
	interface IConsommateurOuverture receives ouverture(ouverture) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |ConditionOuverture| behavesAs SM implements IConsommateurAnnonce, IConsommateurZ5_1, IInitialisable {	// Autres noms: Af2, nonAetZ5_1
		private z5_1[1-1] : bool;
		private annonce[1-1] : bool;

		public gestionnaireLiberation[1-1] : GestionnaireLiberation in ConditionOuverture_GestionnaireLiberation;
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				Initialisation -> Ecoute : sysInitSE /
						opaqueBehavior = '
							z5_1 := false;
							annonce := false;
						' in ABCD;;
				Ecoute -> Ecoute : Z5_1LibreSE /
						opaqueBehavior = '
							z5_1 := false;
						' in ABCD;;
				Ecoute -> Ecoute : annonceApprocheSE /
						opaqueBehavior = '
							annonce := true;
						' in ABCD;;
				Ecoute -> Condition : Z5_1OccupeSE /
						opaqueBehavior = '
							z5_1 := true;
						' in ABCD;;
				Ecoute -> Condition : annonceInactiveSE /
						opaqueBehavior = '
							annonce := false;
						' in ABCD;;
				Condition -> Ecoute : [constraint is opaqueExpression = 'z5_1 and (not annonce)' in ABCD;] /
						opaqueBehavior = '
							send ouverture to gestionnaireLiberation;
						' in ABCD;;				// TODO: check non existing || non received signal!
				Condition -> Ecoute : [constraint is opaqueExpression = 'else' in ABCD;] /;
				initial pseudoState Initial;
				choice pseudoState Condition;
			}
		}
	}

	signal clignote;
	signal eteint;
	signal allume;
	interface ILumiere receives clignote(clignote), eteint(eteint), allume(allume) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |Lumiere| behavesAs SM implements IInitialisable, ILumiere {
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				initial pseudoState Initial;
			}
		}
	}

	signal debute;
	signal arret;
	interface ISon receives debute(debute), arret(arret) {}

	comment 'Signal sonore';
	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |Son| behavesAs SM implements IInitialisable, ISon {
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				initial pseudoState Initial;
			}
		}
	}

	signal ouvre;
	signal ferme;
	interface IBarriere receives ouvre(ouvre), ferme(ferme) {}

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |Barriere| behavesAs SM implements IInitialisable, IBarriere {
		stateMachine SM {
			region R {
				Initial -> Initialisation;
				initial pseudoState Initial;
			}
		}
	}

	signal pedaleEnclenchee;
	signalEvent pedaleEnclencheeSE of pedaleEnclenchee;
	interface IConsommateurPedale receives pedaleEnclenchee(pedaleEnclenchee) {}

	signal Z1Libre;
	signalEvent Z1LibreSE of Z1Libre;
	signal Z1Occupe;
	signalEvent Z1OccupeSE of Z1Occupe;
	interface IConsommateurZ1 receives Z1Libre(Z1Libre), Z1Occupe(Z1Occupe) {}

	signal Z3Libre;
	signalEvent Z3LibreSE of Z3Libre;
	signal Z3Occupe;
	signalEvent Z3OccupeSE of Z3Occupe;
	interface IConsommateurZ3 receives Z3Libre(Z3Libre), Z3Occupe(Z3Occupe) {}

	signal Z5Libre;
	signalEvent Z5LibreSE of Z5Libre;
	signal Z5Occupe;
	signalEvent Z5OccupeSE of Z5Occupe;
	interface IConsommateurZ5 receives Z5Libre(Z5Libre), Z5Occupe(Z5Occupe) {}

	signal Z5_1Libre;
	signalEvent Z5_1LibreSE of Z5_1Libre;
	signal Z5_1Occupe;
	signalEvent Z5_1OccupeSE of Z5_1Occupe;
	interface IConsommateurZ5_1 receives Z5_1Libre(Z5_1Libre), Z5_1Occupe(Z5_1Occupe) {}

	association Dispatcher_GestionnaireAnnonce {
		dispatcher[1-1] : Dispatcher;
	}
	association Dispatcher_ConditionFinAnnonce {
		dispatcher[1-1] : Dispatcher;
	}
	association Dispatcher_ConditionOuverture {
		dispatcher[1-1] : Dispatcher;
	}
	association Dispatcher_Controleur {
		dispatcher[1-1] : Dispatcher;
	}
	association Dispatcher_GestionnaireLiberation {
		dispatcher[1-1] : Dispatcher;
	}

	signal ini;
	signalEvent iniSE of ini;

	<<pathmap://SysML_PROFILES/SysML.profile.uml#//Blocks/Block>>
	class |Dispatcher| behavesAs SM implements IConsommateurZ1, IConsommateurZ3, IConsommateurZ5, IConsommateurZ5_1, IConsommateurPedale receives ini(ini) {
		controleur[1-1] : Controleur in Dispatcher_Controleur;
		gestionnaireAnnonce[1-1] : GestionnaireAnnonce in Dispatcher_GestionnaireAnnonce;
		gestionnaireLiberation[1-1] : GestionnaireLiberation in Dispatcher_GestionnaireLiberation;
		conditionFinAnnonce[1-1] : ConditionFinAnnonce in Dispatcher_ConditionFinAnnonce;
		conditionOuverture[1-1] : ConditionOuverture in Dispatcher_ConditionOuverture;
		stateMachine SM {
			region R {
				Initial -> s0;
				s0 -> s0 : iniSE /
						opaqueBehavior = '
	                        send sysInit to controleur;
	                        send sysInit to gestionnaireAnnonce;
	                        send sysInit to gestionnaireLiberation;
	                        send sysInit to conditionFinAnnonce;
	                        send sysInit to conditionOuverture;
						' in ABCD;;
				s0 -> s0 : Z1LibreSE /
						opaqueBehavior = '
	                        send Z1Libre to conditionFinAnnonce;
						' in ABCD;;
				s0 -> s0 : Z1OccupeSE /
						opaqueBehavior = '
	                        send Z1Occupe to conditionFinAnnonce;
						' in ABCD;;
				s0 -> s0 : pedaleEnclencheeSE /
						opaqueBehavior = '
	                        send pedaleEnclenchee to gestionnaireAnnonce;
						' in ABCD;;
				s0 -> s0 : Z3LibreSE /
						opaqueBehavior = '
	                        send Z3Libre to conditionFinAnnonce;
	                        send Z3Libre to gestionnaireAnnonce;
						' in ABCD;;
				s0 -> s0 : Z3OccupeSE /
						opaqueBehavior = '
	                        send Z3Occupe to conditionFinAnnonce;
	                        send Z3Occupe to gestionnaireAnnonce;
						' in ABCD;;
				s0 -> s0 : Z5LibreSE /
						opaqueBehavior = '
	                        send Z5Libre to conditionFinAnnonce;
	                        send Z5Libre to gestionnaireAnnonce;
						' in ABCD;;
				s0 -> s0 : Z5OccupeSE /
						opaqueBehavior = '
	                        send Z5Occupe to conditionFinAnnonce;
	                        send Z5Occupe to gestionnaireAnnonce;
						' in ABCD;;
				s0 -> s0 : Z5_1LibreSE /
						opaqueBehavior = '
	                        send Z5_1Libre to conditionOuverture;
						' in ABCD;;
				s0 -> s0 : Z5_1OccupeSE /
						opaqueBehavior = '
	                        send Z5_1Occupe to conditionOuverture;
						' in ABCD;;
				initial pseudoState Initial;
			}
		}
	}

	// TODO: rewrite to have a single Zone class with an identifier (from an enumeration)
	//	=> but how do we handle the multiple targets?
	// TODO: in check for received events, also consider super classes

	// TODO, get rid of MANUAL MODIFICATION CURRENTLY REQUIRED in output.abcd:
	// DONE:
	//	- add select/end select for multiple incoming transitions on choice
	//	- int -> bool for some variables
	//	- reordering Zone5 arguments (because we removed sortedBy in UML2ABCD... we should put it back SOON)

	// TODO, resolve other open issues:
	//	- injected UML model behaves differently when 1) serialized then reloaded vs. 2) just injected
	//		- notably:
	//			- memberEnd of associations are correctly set in 1), but incorrect in 2)
	//		- to check this: compare Case1.tuml.uml to Case1.tuml when both are loaded in UML Editor
}
